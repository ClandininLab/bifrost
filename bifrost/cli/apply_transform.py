""" Logic to apply transform generated by 'bifrost register' to an image

Execute using the 'bifrost' executable installed by setuptools
"""


import logging
import os
import sys
import tempfile

import ants
import h5py
import numpy as np
import tensorflow as tf
import voxelmorph as vxm
from skimage.exposure import equalize_adapthist

from bifrost.io import md5sum, read_affine, read_image
from bifrost.util import transpose_image, update_image_array

# hide GPUs
os.environ["CUDA_VISIBLE_DEVICES"] = ""
# suppress tensorflow import warnings
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"


def transform(args):

    # ========================================================================== #
    #                      PARSE ARGS, CONFIGURE LOGGER                          #
    # ========================================================================== #
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)

    stdout_handler = logging.StreamHandler(stream=sys.stdout)
    # don't log errors, those get sent to stderr
    stdout_handler.addFilter(lambda x: x.levelno < logging.WARNING)
    logger.addHandler(stdout_handler)

    error_handler = logging.StreamHandler(stream=sys.stderr)
    error_handler.setLevel(logging.WARNING)
    logger.addHandler(error_handler)

    # ========================================================================== #
    #                        CONFIGURE LOGGING VERBOSITY                         #
    # ========================================================================== #

    if args.verbose:
        stdout_handler.setLevel(logging.INFO)
    else:
        stdout_handler.setLevel(logging.CRITICAL + 1)

    # ========================================================================== #
    #                      CONFIGURE LOG FILE HANDLER                            #
    # ========================================================================== #

    if args.log is None:
        log_name = (
            f'{os.path.basename(args.image_path).split(".")[0]}_apply_transform.log'
        )
        log_path = f"{args.alignment_path}/{log_name}"
    else:
        log_path = args.log

    logger.info("Writings logs to %s", log_path)

    file_handler = logging.FileHandler(log_path)
    file_handler.setLevel(logging.DEBUG)

    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    file_handler.setFormatter(formatter)

    logger.addHandler(file_handler)

    # ========================================================================== #
    #                             INPUT VALIDATION                               #
    # ========================================================================== #

    logger.debug("Parsed args: %s", args)

    assert "transform.h5" in os.listdir(args.alignment_path)

    logger.info("Loading moving image: %s", args.image_path)
    moving_img = ants.image_read(args.image_path)
    logger.info("Moving image hash: %s", md5sum(args.image_path))
    logger.info("Moving image info: \n %s", repr(moving_img))

    with h5py.File(f"{args.alignment_path}/transform.h5", "r") as h5_handle:

        fixed_img = ants.from_numpy(
            np.zeros(h5_handle.attrs["fixed.shape"]),
            origin=tuple(h5_handle.attrs["fixed.origin"]),
            spacing=tuple(h5_handle.attrs["fixed.spacing"]),
            direction=h5_handle.attrs["fixed.direction"],
            has_components=h5_handle.attrs["fixed.has_components"],
        )

        if args.label_image:
            resample_method = 1
        else:
            resample_method = 3

        lobe_mask = None

        if "lobe_mask" in h5_handle:
            logger.info("Loading lobe mask")
            lobe_mask = read_image(h5_handle, "/lobe_mask")

        if h5_handle.attrs["args.downsample_to"] > 0:
            desired_spacing = (h5_handle.attrs["args.downsample_to"],) * 3

            logger.info(
                "Resampling image. Current resolution: {}, Desired resolution: {}".format(
                    moving_img.spacing, desired_spacing
                )
            )

            moving_img = ants.resample_image(
                moving_img, desired_spacing, interp_type=resample_method
            )

            fixed_img = ants.resample_image(
                fixed_img, desired_spacing, interp_type=resample_method
            )

            if lobe_mask is not None:
                logger.info(
                    "Resampling mask. Current resolution: {}, Desired resolution: {}".format(
                        lobe_mask.spacing, desired_spacing
                    )
                )

                lobe_mask = ants.resample_image(
                    lobe_mask, desired_spacing, interp_type=1
                )

        # ========================================================================== #
        #                                  RESCALE                                   #
        # ========================================================================== #

        if args.apply_preprocessing and not args.label_image:
            logger.info("Rescaling images")
            logger.info(
                "Moving intensity range: %s - %s", moving_img.min(), moving_img.max()
            )
            moving_img -= moving_img.min()
            moving_img /= moving_img.max()

        # ========================================================================== #
        #                          HISTOGRAM EQUALIZATION                            #
        # ========================================================================== #

        if args.apply_preprocessing and not args.label_image:
            if h5_handle.attrs["args.moving_clip_limit"] > 0:
                logger.info(
                    "Running moving CLAHE. Clip limit: %s",
                    h5_handle.attrs["args.moving_clip_limit"],
                )

                moving_clahe = equalize_adapthist(
                    moving_img.numpy(),
                    # get won't throw a key error if args.clahe_kernel_size doesn't exist (it might not)
                    kernel_size=h5_handle.attrs.get("args.clahe_kernel_size"),
                    clip_limit=h5_handle.attrs["args.moving_clip_limit"],
                )

                moving_img = update_image_array(moving_img, moving_clahe)

        # ========================================================================== #
        #                                  AFFINE                                    #
        # ========================================================================== #

        if args.label_image:
            interpolator = "nearestNeighbor"
        else:
            interpolator = "linear"

        if "affine" in h5_handle:
            logger.info("Apply affine transform")

            with tempfile.TemporaryDirectory() as tmp_dir:
                affine_path = read_affine(h5_handle, "/affine", directory=tmp_dir)

                moving_img = ants.apply_transforms(
                    fixed_img,
                    moving_img,
                    transformlist=[affine_path],
                    interpolator=interpolator,
                )

                if lobe_mask is not None:
                    lobe_mask = ants.apply_transforms(
                        fixed_img,
                        lobe_mask,
                        transformlist=[affine_path],
                        interpolator=interpolator,
                    )

        # ========================================================================== #
        #                        SYMMETRIC NORMALIZATION                             #
        # ========================================================================== #

        if "syn" in h5_handle:

            with tempfile.TemporaryDirectory() as tmp_dir:
                affine_path = read_affine(h5_handle, "/syn/affine", directory=tmp_dir)

                syn_path = read_image(h5_handle, "/syn/forward_warp", directory=tmp_dir)

                logger.info("Apply SyN transforms")

                moving_img = ants.apply_transforms(
                    fixed_img,
                    moving_img,
                    transformlist=[syn_path, affine_path],
                    interpolator=interpolator,
                )

                if lobe_mask is not None:
                    lobe_mask = ants.apply_transforms(
                        fixed_img,
                        lobe_mask,
                        transformlist=[syn_path, affine_path],
                        interpolator=interpolator,
                    )

        # ========================================================================== #
        #                                SYNTHMORPH                                  #
        # ========================================================================== #

        if "synthmorph" in h5_handle:

            warp = h5_handle["/synthmorph"][:]

            logger.info("Transposing image")

            optimal_transposition = np.argsort(moving_img.shape)
            inverse_transposition = np.argsort(optimal_transposition)

            moving_img = transpose_image(moving_img, optimal_transposition)

            logger.info("Applying synthmorph transform")

            with tf.device("/CPU:0"):
                transform = vxm.networks.Transform(moving_img.shape, nb_feats=1)

                # transform label image component-by-component
                if args.label_image:
                    warped = np.zeros(moving_img.shape)

                    for label in np.unique(moving_img.numpy()):
                        mask = moving_img.numpy() == label

                        label_image = np.zeros(moving_img.shape)
                        label_image[mask] = 1

                        warped_label_image = transform.predict(
                            [
                                label_image.reshape((1,) + moving_img.shape + (1,)),
                                warp.reshape((1,) + warp.shape),
                            ]
                        ).squeeze()

                        warped_mask = warped_label_image > 0
                        warped_label_image[warped_mask] = 1

                        warped[warped_mask] = label
                else:
                    warped = transform.predict(
                        [
                            moving_img.numpy().reshape((1,) + moving_img.shape + (1,)),
                            warp.reshape((1,) + warp.shape),
                        ]
                    ).squeeze()

            if lobe_mask is not None:
                lobe_mask = (
                    transpose_image(lobe_mask, optimal_transposition).numpy() > 0
                )
                warped[lobe_mask] = moving_img[lobe_mask]

            moving_img = np.transpose(warped, inverse_transposition)

        # ========================================================================== #
        #                              WRITE IMAGE                                   #
        # ========================================================================== #

        print(args.result_name)
        if args.result_name is None:
            result_name = (
                f'{os.path.basename(args.image_path).split(".")[0]}_transformed.nii'
            )
            result_path = f"{args.alignment_path}/{result_name}"
        # interpreted as absolute path
        elif args.result_name.startswith("/") or args.result_name.startswith("./"):
            os.makedirs(os.path.dirname(args.result_name), exist_ok=True)
            result_path = args.result_name
        # interpreted as just a name
        else:
            result_path = f"{args.alignment_path}/{args.result_name}"

        if not isinstance(moving_img, ants.ANTsImage):
            moving_img = ants.from_numpy(
                moving_img,
                origin=fixed_img.origin,
                spacing=fixed_img.spacing,
                direction=fixed_img.direction,
                has_components=fixed_img.has_components,
            )

        ants.image_write(moving_img, result_path)

        logger.info(f"Wrote transformed image to {result_path}")
